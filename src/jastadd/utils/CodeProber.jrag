aspect PASTA {
  String Program.generateMagicProblemString(String type, Problem p) {
    int col = p.column;
    if (col == -1) {
      col = 0;
    }
    int packedStart = (p.line << 12) + col;

    int packedEnd;
    if (p.endLine == -1) {
      packedEnd = ((p.line + 1) << 12) - 1;
    } else {
      int endCol = p.endColumn;
      if (endCol == -1) {
        endCol = 0xFFF;
      }
      packedEnd = ((p.endLine << 12) + endCol);
    }
    System.out.printf("%s@%d;%d;%s\n", type, packedStart, packedEnd, p.message);
    return String.format("[%d:%d..%d:%d]: %s", p.line, p.column, p.endLine,
                         p.endColumn, p.message);
  }

  syn java.util.List<String> Program.showProblems() {
    java.util.List<String> ret = new java.util.ArrayList<>();
    for (CompilationUnit unit : getCompilationUnits()) {
      for (Problem p : unit.errors()) {
        ret.add(generateMagicProblemString("ERR", p));
      }
      for (Problem p : unit.warnings()) {
        ret.add(generateMagicProblemString("WARN", p));
      }
    }
    return ret;
  }

syn
  java.util.List<Diagnostic> Program.showCFG() {
    java.util.List<Diagnostic> ret = new java.util.ArrayList<>();
    for (CompilationUnit unit : getCompilationUnitList()) {
      for (CFGRoot t : unit.CFGRoots()) {
        ASTNode node = (ASTNode)t;
        traverseCFG(t.entry(), new HashSet<CFGNode>(), ret);
      }
    }
    return ret;
  }

syn
  java.util.List<Diagnostic> MethodDecl.showCFG() {
    java.util.List<Diagnostic> ret = new java.util.ArrayList<>();
    traverseCFG(entry(), new HashSet<CFGNode>(), ret);
    return ret;
  }
public
  void ASTNode.traverseCFG(CFGNode t, Set<CFGNode> nodes,
                           java.util.List<Diagnostic> ret) {
    if (nodes.contains(t))
      return;
    nodes.add(t);
    ASTNode node1 = (ASTNode)t;
    for (CFGNode n : t.succ()) {
      ASTNode node2 = (ASTNode)n;
      Random rand = new Random(node1.getStart());

      final int[] components =
          new int[]{10 + rand.nextInt(6), rand.nextInt(16), rand.nextInt(6)};

      final int off = rand.nextInt(3);
      final int r = components[off % 3];
      final int g = components[(off + 1) % 3];
      final int b = components[(off + 2) % 3];
      final int col = (r << 12) + (g << 8) + (b << 4) + 0x6;
      final String colStr = String.format("#%04x", col);

      ret.add(new Diagnostic(java.util.Arrays.asList(),
                             String.format("LINE-PA@%d;%d;%s", node1.getStart(),
                                           node2.getStart(), colStr)));
      traverseCFG(n, nodes, ret);
    }
  }

  class Diagnostic {
    Object humanReadable;
    String diagnostic;

  public
    Diagnostic(Object humanReadable, String diagnostic) {
      this.humanReadable = humanReadable;
      this.diagnostic = diagnostic;
    }

  public
    Object cpr_getOutput() { return humanReadable; }
  public
    String cpr_getDiagnostic() { return diagnostic; }

    @Override public String toString() {
      return humanReadable + "";
    }

  public
    boolean equals(Object other) {
      if (!(other instanceof Diagnostic)) {
        return false;
      }
      Diagnostic o = (Diagnostic)other;
      return humanReadable.equals(o.humanReadable) &&
             diagnostic.equals(o.diagnostic);
    }
  }

  syn Object MethodDecl.bytecodes() {
    // flushTreeCache();
    final ConstantPool pool = hostType().constantPool(); // new ConstantPool(hostType());
    // hostType().constantPoolPtr()[0] = pool;
    final CodeGeneration gen = bytecodes(pool);
    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
    final String utf8 = java.nio.charset.StandardCharsets.UTF_8.name();
    try (PrintStream ps = new PrintStream(baos, true, utf8)) {
        gen.printBytecodes(ps);
        final java.util.List<Object> ret = new ArrayList<>();

        for (String line : baos.toString(utf8).split("\n")) {
          String pc = line.trim().split("\\s")[0];
          try {
            int pcInt = Integer.parseInt(pc);
            CodeGeneration.LineNumberEntry bestEntry = null;
            for (CodeGeneration.LineNumberEntry lne : gen.lineNumberTable) {
              if (lne.start_pc > pcInt) {
                break;
              }
              bestEntry = lne;
            }
            if (bestEntry != null) {
              ret.add(new Diagnostic(
                line,
                String.format("HLHOVER@%d;%d", (bestEntry.line_number << 12) + 1, ((bestEntry.line_number + 1) << 12) - 1)
              ));
              continue;
            }
          } catch (NumberFormatException e) {
            // Ignore, fall down
          }

          ret.add(line);
        }
        return ret;
    } catch (UnsupportedEncodingException e) {
      throw new RuntimeException("utf-8 is not supported? This 'should never happen'", e);
    } catch (IOException e) {
      throw new RuntimeException("IOException thrown when writing to in-memory stream. This 'should never happen'", e);
    }
  }

  syn Object Declarator.showAccessors() = showAccessors("#f00");

  syn Object Declarator.showAccessors(String color) {
    final HashSet<VarAccess> ret = accessors();
    final java.util.List<Diagnostic> diags = new ArrayList<>();
    for (VarAccess acc : ret) {
      diags.add(new Diagnostic(
        acc,
        String.format("LINE-PA@%d;%d;%s", getStart() + getID().length(), acc.getStart(), color)
      ));
    }
    return diags;
  }

  coll HashSet<VarAccess> Declarator.accessors() root CompilationUnit;

  VarAccess contributes this
    when (decl() instanceof Declarator)
    to Declarator.accessors()
    for decl()
    ;
}
